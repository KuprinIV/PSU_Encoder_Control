/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include "stm32f030x6.h"
#include "system_stm32f0xx.h"

//#define USE_PLL 			1
#define EC1A_Pin			GPIO_IDR_3
#define EC1B_Pin			GPIO_IDR_2
#define EC1_Btn				GPIO_IDR_4
#define EC2A_Pin			GPIO_IDR_9
#define EC2B_Pin			GPIO_IDR_10
#define EC2_Btn				GPIO_IDR_5

#define MAJOR_FILT_AVG		5
#define MAX_CNTR_VALUE		800
#define SCAN_PERIOD_US		100

typedef struct
{
	uint8_t a_pin_state;
	uint8_t b_pin_state;
	uint8_t btn_state;
	uint8_t a_pin_state_prev;
	uint8_t b_pin_state_prev;
	uint8_t btn_state_prev;
}EncoderState;

static uint8_t majorFilter(EncoderState* eca, EncoderState* ecb);


// init variables
uint16_t tim14_psc = 0, tim14_arr = 0;
int16_t vu_ccr_default = 118, vi_ccr_default = 290;
int16_t vu_cntr = 0, vi_cntr = 0;
uint8_t eca_btn_cntr = 0, ecb_btn_cntr = 0;
uint16_t step_vals[2] = {1, 5};

volatile uint8_t is_update_event = 0;

// init encoders state with default values
EncoderState enc_A = {1, 1, 1, 1, 1, 1}, enc_B = {1, 1, 1, 1, 1, 1};

int main(void)
{
	//clock init
 	RCC->CR |= RCC_CR_HSEON|RCC_CR_HSEBYP; // HSE bypass clock init
	while(!(RCC->CR & RCC_CR_HSERDY)){}
#ifdef USE_PLL
	RCC->CFGR |= RCC_CFGR_PLLMUL2|RCC_CFGR_PLLSRC_HSE_PREDIV|RCC_CFGR_PLLXTPRE_HSE_PREDIV_DIV1; //set PLL clock as system clock
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY)){}
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	tim14_psc = 15;
	tim14_arr = SCAN_PERIOD_US-1;
#else
	RCC->CFGR |= RCC_CFGR_SW_HSE; //set HSE clock as system clock
	tim14_psc = 7;
	tim14_arr = SCAN_PERIOD_US-1;
#endif

	//GPIO init: PA2 - EC1B (IN), PA3 - EC1A (IN), PA4 - EC1 button (IN), PA5 - EC2 button (IN),
	// PA6 - TIM16 CH1 PWM (AF OUT), PA7 - TIM17 CH1 PWM (AF OUT), PA9 - EC2A (IN), PA10 - EC2B (IN)
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN; 	// enable GPIOA clock
	GPIOA->MODER |= 0x0000A000;			// configure pins mode
	GPIOA->AFR[0] |= 0x55000000; 		//select AF5 function for PA6 and PA7

	//TIM16 and channel 1 init PWM
    RCC->APB2ENR |= RCC_APB2ENR_TIM16EN; 	// enable timer clock
	TIM16->PSC = 0;
	TIM16->ARR = MAX_CNTR_VALUE-1;
	// enable PWM 1 mode and update CCR value at timer update event
	TIM16->CCMR1 |= TIM_CCMR1_OC1M_2|TIM_CCMR1_OC1M_1|TIM_CCMR1_OC1PE;
	TIM16->CR1 |= TIM_CR1_ARPE; 			// enable ARR register preload
	TIM16->CCR1 = vi_ccr_default; 			// set default Vi duty cycle
	TIM16->CCER |= TIM_CCER_CC1E; 			// enable CH1
	TIM16->BDTR |= TIM_BDTR_MOE;			// enable master output
	TIM16->CR1 |= TIM_CR1_CEN;				// enable timer - start PWM generation

	//TIM17 and channel 1 init PWM
	RCC->APB2ENR |= RCC_APB2ENR_TIM17EN;	// enable timer clock
	TIM17->PSC = 0;
	TIM17->ARR = MAX_CNTR_VALUE-1;
	// enable PWM 1 mode and update CCR value at timer update event
	TIM17->CCMR1 |= TIM_CCMR1_OC1M_2|TIM_CCMR1_OC1M_1|TIM_CCMR1_OC1PE;
	TIM17->CR1 |= TIM_CR1_ARPE;				// enable ARR register preload
	TIM17->CCR1 = vu_ccr_default;			// set default Vu duty cycle
	TIM17->CCER |= TIM_CCER_CC1E;			// enable CH1
	TIM17->BDTR |= TIM_BDTR_MOE;			// enable master output
	TIM17->CR1 |= TIM_CR1_CEN;				// enable timer - start PWM generation

	//TIM14 value scanning timer
	RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;	// enable timer clock
	TIM14->PSC = tim14_psc;
	TIM14->ARR = tim14_arr;
	TIM14->EGR |= TIM_EGR_UG;				// enable update event generation
	TIM14->DIER |= TIM_DIER_UIE;			// enable update event interrupt
	TIM14->CR1 |= TIM_CR1_CEN|TIM_CR1_ARPE;	// enable timer and ARR register preload
	// enable interrupt
	NVIC_SetPriority(TIM14_IRQn, 1);
	NVIC_EnableIRQ(TIM14_IRQn);

	// init default values
	vu_cntr = vu_ccr_default;
	vi_cntr = vi_ccr_default;

    /* Loop forever */
	while(1)
	{
		// check update event
		if(is_update_event)
		{
			is_update_event = 0;
			// scan encoders pins
			if(majorFilter(&enc_A, &enc_B))
			{
				// handle encoder 1 button state
				if(!enc_A.btn_state && enc_A.btn_state_prev)
				{
					// button is pressed
					eca_btn_cntr = (eca_btn_cntr + 1) & 0x01;
				}

				// handle encoder 1 state
				// detect A signal rising edge
				if(enc_A.a_pin_state && !enc_A.a_pin_state_prev)
				{
					// detect turn direction by A and B signal level
					if(enc_A.a_pin_state == enc_A.b_pin_state)
					{
						vu_cntr -= step_vals[eca_btn_cntr];
						// limit minimum counter value
						if(vu_cntr < 0) vu_cntr = 0;
					}
					else
					{
						vu_cntr += step_vals[eca_btn_cntr];
						// limit maximum counter value
						if(vu_cntr > MAX_CNTR_VALUE-1) vu_cntr = MAX_CNTR_VALUE-1;
					}
				}

				// handle encoder 2 button state
				if(!enc_B.btn_state && enc_B.btn_state_prev)
				{
					// button is pressed
					ecb_btn_cntr = (ecb_btn_cntr + 1) & 0x01;
				}

				// handle encoder 2 state
				// detect A signal rising edge
				if(enc_B.a_pin_state && !enc_B.a_pin_state_prev)
				{
					// detect turn direction by A and B signal level
					if(enc_B.a_pin_state == enc_B.b_pin_state)
					{
						vi_cntr -= step_vals[ecb_btn_cntr];
						// limit minimum counter value
						if(vi_cntr < 0) vi_cntr = 0;
					}
					else
					{
						vi_cntr += step_vals[ecb_btn_cntr];
						// limit maximum counter value
						if(vi_cntr > MAX_CNTR_VALUE-1) vi_cntr = MAX_CNTR_VALUE-1;
					}
				}

				// update TIMs CCR register
				TIM16->CCR1 = vi_cntr;
				TIM17->CCR1 = vu_cntr;

				// refresh previous encoders state
				enc_A.btn_state_prev = enc_A.btn_state;
				enc_A.a_pin_state_prev = enc_A.a_pin_state;
				enc_A.b_pin_state_prev = enc_A.b_pin_state;

				enc_B.btn_state_prev = enc_B.btn_state;
				enc_B.a_pin_state_prev = enc_B.a_pin_state;
				enc_B.b_pin_state_prev = enc_B.b_pin_state;
			}
		}
	}
}

/**
 * @brief TIM14 update interrupt handler
 * @param: None
 * @return: None
 */
void TIM14_IRQHandler(void)
{
	// check update event interrupt flag
	if(TIM14->SR & TIM_SR_UIF)
	{
		// reset update interrupt flag
		TIM14->SR &= ~TIM_SR_UIF;
		// set update event flag
		is_update_event = 1;
	}
}

/**
  * @brief  Make majoritary filter of encoder signals
  * @param  eca, ecb - data structure with encoders state
  * @retval 0 - output data isn't ready, 1 - output data is ready
  */
static uint8_t majorFilter(EncoderState* eca, EncoderState* ecb)
{
	static uint8_t ticks_cntr;
	static uint8_t ec1a_cntr, ec1b_cntr, ec1_btn_cntr;
	static uint8_t ec2a_cntr, ec2b_cntr, ec2_btn_cntr;
	uint8_t is_ready = 0;

	if(ticks_cntr++ < MAJOR_FILT_AVG)
	{
		// get encoder input pins state
		if(GPIOA->IDR & EC1A_Pin) ec1a_cntr++;
		if(GPIOA->IDR & EC1B_Pin) ec1b_cntr++;
		if(GPIOA->IDR & EC1_Btn) ec1_btn_cntr++;

		if(GPIOA->IDR & EC2A_Pin) ec2a_cntr++;
		if(GPIOA->IDR & EC2B_Pin) ec2b_cntr++;
		if(GPIOA->IDR & EC2_Btn) ec2_btn_cntr++;

		is_ready = 0;
	}
	else
	{
		// set encoders state
		eca->a_pin_state = (ec1a_cntr > MAJOR_FILT_AVG/2+1) ? 1 : 0;
		eca->b_pin_state = (ec1b_cntr > MAJOR_FILT_AVG/2+1) ? 1 : 0;
		eca->btn_state = (ec1_btn_cntr > MAJOR_FILT_AVG/2+1) ? 1 : 0;

		ecb->a_pin_state = (ec2a_cntr > MAJOR_FILT_AVG/2+1) ? 1 : 0;
		ecb->b_pin_state = (ec2b_cntr > MAJOR_FILT_AVG/2+1) ? 1 : 0;
		ecb->btn_state = (ec2_btn_cntr > MAJOR_FILT_AVG/2+1) ? 1 : 0;

		// reset counters
		ec1a_cntr = ec1b_cntr = ec1_btn_cntr = 0;
		ec2a_cntr = ec2b_cntr = ec2_btn_cntr = 0;
		ticks_cntr = 0;

		// set ready flag
		is_ready = 1;
	}
	return is_ready;
}
